options { JAVA_UNICODE_ESCAPE = true; }
PARSER_BEGIN(SLPParser)
public class SLPParser {
    public static void main(String args[]) {
        SLPParser parser;
        if (args.length == 0) {
            System.out.println("SLP Parser: Reading from standard input . . .");
            parser = new SLPParser(System.in);
        } else if (args.length == 1) {
            System.out.println("SLP Parser: Reading from file " + args[0] + " . . .");
            try {
                parser = new SLPParser(new java.io.FileInputStream(args[0]));
            } catch (java.io.FileNotFoundException e) {
                System.out.println("SLP Parser: File " + args[0] + " not found.");
                return;
            }
        } else {
            System.out.println("SLP Parser: Usage is one of:");
            System.out.println(" java SLPParser < inputfile");
            System.out.println("OR");
            System.out.println(" java SLPParser inputfile");
            return;
        }
        try {
            parser.Prog(); // start point of the program
            System.out.println("SLP Parser: SLP program parsed successfully.");
        } catch (ParseException e) {
            System.out.println(e.getMessage());
            System.out.println("SLP Parser: Encountered errors during parse.");
        }
    }
}
PARSER_END(SLPParser)
/*****************************************
***** SECTION 3 - TOKEN DEFINITIONS *****
*****************************************/
TOKEN_MGR_DECLS :
{
    static int commentNesting = 0;
}
SKIP : /*** Ignoring spaces/tabs/newlines ***/
{
    " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"
}

SKIP : /* COMMENTS */
{
    "/*" { commentNesting++; } : IN_COMMENT
    | "//" : IN_COMMENT
}
<IN_COMMENT> SKIP :
{
    "/*" { commentNesting++; }
    | "*/" { commentNesting--;
        if (commentNesting == 0)
        SwitchTo(DEFAULT);
    }
    | <~[]>
}
TOKEN : /* Keywords and punctuation */
{
    < SEMIC : ";" >
    | < COLON : ":" >
    | < ASSIGN : ":=" >
    | < PRINT : "print" >
    | < LBR : "(" >
    | < RBR : ")" >
    | < COMMA : "," >
    | < PLUS_SIGN : "+" >
    | < MINUS_SIGN : "-" >
    | < MULT_SIGN : "*" > // TODO take this one out and make multiply function later
    | < DIV_SIGN : "/" >
}

TOKEN [IGNORE_CASE]: /* Keywords */
{
    < RETURN : "return" >
    | < MAIN : "main" >
    | < BEGIN : "begin" >
    | < END : "end" >
    | < VARIABLE : "variable" >
    | < CONSTANT : "constant" >
    | < TYPE : ("integer" | "boolean") >
    | < IS : "is" >
}

TOKEN: /* Logical Operators */
{
    < LOG_NEG : "~" > // logical negation
    | < LOG_DIS : "|" > // logical disjunction
    | < LOG_AND : "&" > // logical and
}

TOKEN: /* Comparison Operators */
{
    < EQUALS : "=" > // logical equals
    | < NOT_EQUALS : "!=" > // not equals
    | < LESS_THAN : "<" > // less than
    | < LESS_EQUALS: "<=" > // less than or equals 
    | < GREATER_THAN: ">" > // greater than
    | < GREATER_EQUALS: ">=" > // greater than or equals
}

TOKEN : /* Numbers and identifiers */
{
    < NUM : ("-")*(<DIGIT>)+ > // num can start with a minus
    | < #DIGIT : ["0" - "9"] >
    | < ID : (<LETTER>)+ >
    | < #LETTER : ["a" - "z", "A" - "Z", "_"] >
}

TOKEN : /* Anything not recognised so far */
{
    < OTHER : ~[] >
}
/***********************************
***** SECTION 4 - THE GRAMMAR *****
***********************************/

void Prog() : {}
{
    decl_list()
    | func_list() <EOF>
}

void decl_list() : {}
{
    (decl() [<SEMIC> decl_list()])
}

void decl() : {}
{
    var_decl()
    | const_decl()
}

void var_decl() : {}
{
    (<VARIABLE> [<ID> <COLON> <TYPE>])
}

void const_decl() : {}
{
    (<CONSTANT> [<ID> <COLON> <TYPE>])
}

void func_list() : {}
{
    (func() [func_list()])
}

void func() : {}
{
    (<TYPE> <ID> <LBR>) (param_list())* (<RBR> <IS>) (decl_list())* (<BEGIN> statement_block() <RETURN> <END>)
}

void statement_block() : {}
{
    (statement() [statement_block()])
}

void statement() : {}
{
    <ID> // TODO: replace this with the actual statement 
    // this includes implementing the fragment, expression and the rest of the 
    // stuff that is involved with statement
}

void param_list() : {}
{
    (nemp_param_list())
}

void nemp_param_list() : {}
{
    (param() [<COMMA> nemp_param_list()])
}

void param() : {} 
{
    <ID> <COLON> <TYPE>
}