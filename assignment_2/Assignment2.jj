/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Assignment2.jj */
/*@egen*/options { 
    JAVA_UNICODE_ESCAPE = true;
                 
                   
}
PARSER_BEGIN(SLPParser)
import java.util.*;
import java.io.*;

public class SLPParser/*@bgen(jjtree)*/implements SLPParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTSLPParserState jjtree = new JJTSLPParserState();

/*@egen*/
    public static Hashtable ST = new Hashtable();
    public static void main(String args[]) throws ParseException, FileNotFoundException {
        if (args.length < 1) {
            System.out.println("Please supply a source file to compile");
            return;
        }
        SLPParser parser = new SLPParser(new FileInputStream(args[0]));
        SimpleNode root = parser.Prog();
    }
}
PARSER_END(SLPParser)
/*****************************************
***** SECTION 3 - TOKEN DEFINITIONS *****
*****************************************/
TOKEN_MGR_DECLS :
{
    static int commentNesting = 0;
}
SKIP : /*** Ignoring spaces/tabs/newlines ***/
{
    " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"
    | < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}

SKIP : /* COMMENTS */
{
    "/*" { commentNesting++; } : IN_COMMENT
}
<IN_COMMENT> SKIP :
{
    "/*" { commentNesting++; }
    | "*/" { commentNesting--;
        if (commentNesting == 0)
        SwitchTo(DEFAULT);
    }
    | <~[]>
}
TOKEN : /* Keywords and punctuation */
{
    < SEMIC : ";" >
    | < COLON : ":" >
    | < ASSIGN : ":=" >
    | < PRINT : "print" >
    | < LBR : "(" >
    | < RBR : ")" >
    | < COMMA : "," >
    | < PLUS_SIGN : "+" >
    | < MINUS_SIGN : "-" >
    | < DIV_SIGN : "/" >
}

TOKEN [IGNORE_CASE]: /* Keywords */
{
    < RETURN : "return" >
    | < MAIN : "main" >
    | < BEGIN : "begin" >
    | < END : "end" >
    | < VARIABLE : "variable" >
    | < CONSTANT : "constant" >
    | < TYPE : ("integer" | "boolean") >
    | < IS : "is" >
    | < BOOL : "true" | "false" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < WHILE : "while" > 
    | < SKIP_WORD : "skip" > 
}

TOKEN: /* Logical Operators */
{
    < LOG_NEG : "~" > // logical negation
    | < LOG_DIS : "|" > // logical disjunction
    | < LOG_AND : "&" > // logical and
}

TOKEN: /* Comparison Operators */
{
    < EQUALS : "=" > // logical equals
    | < NOT_EQUALS : "!=" > // not equals
    | < LESS_THAN : "<" > // less than
    | < LESS_EQUALS: "<=" > // less than or equals 
    | < GREATER_THAN: ">" > // greater than
    | < GREATER_EQUALS: ">=" > // greater than or equals
}

TOKEN : /* Numbers and identifiers */
{
    < NUM : ("-")*(<DIGIT>)+ > // num can start with a minus
    | < #DIGIT : ["0" - "9"] >
    | < ID : <LETTER> (<LETTER> | <DIGIT>)* >
    | < #LETTER : ["a" - "z", "A" - "Z", "_"] >
}

TOKEN : /* Anything not recognised so far */
{
    < OTHER : ~[] >
}
/***********************************
***** SECTION 4 - THE GRAMMAR *****
***********************************/

void Prog()          : {/*@bgen(jjtree) PROGRAM */
  ASTPROGRAM jjtn000 = new ASTPROGRAM(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PROGRAM */
    try {
/*@egen*/
    code() <EOF>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void code()       : {/*@bgen(jjtree) VOID */
  ASTVOID jjtn000 = new ASTVOID(JJTVOID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VOID */
    try {
/*@egen*/
    (block() [code()])/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void block()       : {/*@bgen(jjtree) VOID */
  ASTVOID jjtn000 = new ASTVOID(JJTVOID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VOID */
    try {
/*@egen*/
    decl_list()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
    //| func_list()
    //| main_statement()
}

void decl_list()       : {/*@bgen(jjtree) VOID */
  ASTVOID jjtn000 = new ASTVOID(JJTVOID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VOID */
    try {
/*@egen*/
    (decl() [<SEMIC> decl_list()])/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void decl()       : {/*@bgen(jjtree) VOID */
  ASTVOID jjtn000 = new ASTVOID(JJTVOID);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) VOID */
    try {
/*@egen*/
    var_decl()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
    //| const_decl()
}

void var_decl()       : {/*@bgen(jjtree) VOID */
                          ASTVOID jjtn000 = new ASTVOID(JJTVOID);
                          boolean jjtc000 = true;
                          jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; String name; }
{/*@bgen(jjtree) VOID */
    try {
/*@egen*/  
    // I know I said get it working but I have not added
    // the symbol table functionality to this (but it is done)

    t = <TYPE> name = id()/*@bgen(jjtree) #VAR( 1) */
                           {
                             ASTVAR jjtn001 = new ASTVAR(JJTVAR);
                             boolean jjtc001 = true;
                             jjtree.openNodeScope(jjtn001);
                           }
                           try {
/*@egen*//*@bgen(jjtree)*/
                           {
                             jjtree.closeNodeScope(jjtn001,  1);
                             jjtc001 = false;
                           }
/*@egen*/ {jjtn001.value = t.image;}/*@bgen(jjtree)*/
                           } finally {
                             if (jjtc001) {
                               jjtree.closeNodeScope(jjtn001,  1);
                             }
                           }
/*@egen*/        /*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

String id()       : {/*@bgen(jjtree) VOID */
                      ASTVOID jjtn000 = new ASTVOID(JJTVOID);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) VOID */
    try {
/*@egen*/
    t = <ID>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {jjtn000.value = t.image; return t.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}