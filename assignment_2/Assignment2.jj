/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Assignment2.jj */
/*@egen*/options { 
    JAVA_UNICODE_ESCAPE = true;
                 
                   
}
PARSER_BEGIN(SLPParser)
import java.util.*;
import java.io.*;

public class SLPParser/*@bgen(jjtree)*/implements SLPParserTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTSLPParserState jjtree = new JJTSLPParserState();

/*@egen*/
    public static SymbolTable ST = new SymbolTable();
    //public static SymbolTable ST = new SymbolTable();
    public static void main(String args[]) throws ParseException, FileNotFoundException {
        if (args.length < 1) {
            System.out.println("Please supply a source file to compile");
            return;
        }
        SLPParser parser = new SLPParser(new FileInputStream(args[0]));
        SimpleNode root = parser.Prog();
        root.dump("");
        TypeCheckVisitor tc = new TypeCheckVisitor();
        root.jjtAccept(tc, ST);
        // System.out.println(ST.check("x"));
        // System.out.println(ST.get("y")); 
    }
}
PARSER_END(SLPParser)
/*****************************************
***** SECTION 3 - TOKEN DEFINITIONS *****
*****************************************/
TOKEN_MGR_DECLS :
{
    static int commentNesting = 0;
}
SKIP : /*** Ignoring spaces/tabs/newlines ***/
{
    " "
    | "\t"
    | "\n"
    | "\r"
    | "\f"
    | < "//" (~["\n","\r"])* ("\n" | "\r" | "\r\n") >
}

SKIP : /* COMMENTS */
{
    "/*" { commentNesting++; } : IN_COMMENT
}
<IN_COMMENT> SKIP :
{
    "/*" { commentNesting++; }
    | "*/" { commentNesting--;
        if (commentNesting == 0)
        SwitchTo(DEFAULT);
    }
    | <~[]>
}
TOKEN : /* Keywords and punctuation */
{
    < SEMIC : ";" >
    | < COLON : ":" >
    | < ASSIGN : ":=" >
    | < PRINT : "print" >
    | < LBR : "(" >
    | < RBR : ")" >
    | < COMMA : "," >
    | < PLUS_SIGN : "+" >
    | < MINUS_SIGN : "-" >
    | < DIV_SIGN : "/" >
}

TOKEN [IGNORE_CASE]: /* Keywords */
{
    < RETURN : "return" >
    | < MAIN : "main" >
    | < BEGIN : "begin" >
    | < END : "end" >
    | < VARIABLE : "variable" >
    | < CONSTANT : "constant" >
    | < TYPE : ("integer" | "boolean") >
    | < IS : "is" >
    | < BOOL : "true" | "false" >
    | < IF : "if" >
    | < ELSE : "else" >
    | < WHILE : "while" > 
    | < SKIP_WORD : "skip" > 
}

TOKEN: /* Logical Operators */
{
    < LOG_NEG : "~" > // logical negation
    | < LOG_DIS : "|" > // logical disjunction
    | < LOG_AND : "&" > // logical and
}

TOKEN: /* Comparison Operators */
{
    < EQUALS : "=" > // logical equals
    | < NOT_EQUALS : "!=" > // not equals
    | < LESS_THAN : "<" > // less than
    | < LESS_EQUALS: "<=" > // less than or equals 
    | < GREATER_THAN: ">" > // greater than
    | < GREATER_EQUALS: ">=" > // greater than or equals
}

TOKEN : /* Numbers and identifiers */
{
    < NUM : ("-")*(<DIGIT>)+ > // num can start with a minus
    | < #DIGIT : ["0" - "9"] >
    | < ID : <LETTER> (<LETTER> | <DIGIT>)* >
    | < #LETTER : ["a" - "z", "A" - "Z", "_"] >
}

TOKEN : /* Anything not recognised so far */
{
    < OTHER : ~[] >
}
/***********************************
***** SECTION 4 - THE GRAMMAR *****
***********************************/

SimpleNode Prog()          : {/*@bgen(jjtree) PROGRAM */
  ASTPROGRAM jjtn000 = new ASTPROGRAM(JJTPROGRAM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PROGRAM */
    try {
/*@egen*/
    code() <EOF>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void code()       : {/*@bgen(jjtree) code */
  ASTcode jjtn000 = new ASTcode(JJTCODE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) code */
    try {
/*@egen*/
    (decl_list())*
    (func_list())*
    main_statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void decl_list()       : {}
{
    (decl() <SEMIC> [/*@bgen(jjtree) #decl_list( 2) */
                     {
                       ASTdecl_list jjtn001 = new ASTdecl_list(JJTDECL_LIST);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
                     }
                     try {
/*@egen*/decl_list()/*@bgen(jjtree)*/
                     } catch (Throwable jjte001) {
                       if (jjtc001) {
                         jjtree.clearNodeScope(jjtn001);
                         jjtc001 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte001 instanceof RuntimeException) {
                         throw (RuntimeException)jjte001;
                       }
                       if (jjte001 instanceof ParseException) {
                         throw (ParseException)jjte001;
                       }
                       throw (Error)jjte001;
                     } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001,  2);
                       }
                     }
/*@egen*/              ])
}

void decl() : {/*@bgen(jjtree) decl */
  ASTdecl jjtn000 = new ASTdecl(JJTDECL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) decl */
    try {
/*@egen*/
    var_decl()  
    | const_decl()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/** DECLARATION **/
void var_decl()       : { Token t; String name; }
{
    <VARIABLE> name = id() <COLON> t = <TYPE>/*@bgen(jjtree) #VAR( 1) */
        {
          ASTVAR jjtn001 = new ASTVAR(JJTVAR);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001,  1);
          jjtc001 = false;
        }
/*@egen*/
        {
            jjtn001.value = t.image;
            System.out.println(name + " is added to the SymbolTable");
            ST.insert(name, t.image); 
            //ST.insert(name);
        }/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
          }
        }
/*@egen*/        
}

void const_decl()       : { Token t; String name; }
{
    <CONSTANT> name = id() <COLON> t = <TYPE>/*@bgen(jjtree) #CONST( 1) */
        {
          ASTCONST jjtn001 = new ASTCONST(JJTCONST);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001,  1);
          jjtc001 = false;
        }
/*@egen*/
        {
            jjtn001.value = t.image;
            System.out.println(name + " is added to the SymbolTable");
            ST.insert(name, t.image);
            //ST.insert(name);
        }/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
          }
        }
/*@egen*/          
}

/** FUNCTION **/
void func_list()       : {}
{
    {ST.newScope();}
    (func() [func_list()])
    {ST.endScope();}
}

void func() : {/*@bgen(jjtree) func */
               ASTfunc jjtn000 = new ASTfunc(JJTFUNC);
               boolean jjtc000 = true;
               jjtree.openNodeScope(jjtn000);
/*@egen*/String name;}
{/*@bgen(jjtree) func */
        try {
/*@egen*/
        <TYPE> name = id() <LBR> (param_list())* <RBR> <IS> (decl_list())* (statement_block())*/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
        {
            ST.insertFunction(name);
        }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void param_list() : {/*@bgen(jjtree) param_list */
  ASTparam_list jjtn000 = new ASTparam_list(JJTPARAM_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) param_list */
    try {
/*@egen*/
    (nemp_param_list())/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void nemp_param_list()       : {}
{   
    param() [<COMMA>/*@bgen(jjtree) #nemp_param_list( 2) */
                     {
                       ASTnemp_param_list jjtn001 = new ASTnemp_param_list(JJTNEMP_PARAM_LIST);
                       boolean jjtc001 = true;
                       jjtree.openNodeScope(jjtn001);
                     }
                     try {
/*@egen*/ nemp_param_list()/*@bgen(jjtree)*/
                     } catch (Throwable jjte001) {
                       if (jjtc001) {
                         jjtree.clearNodeScope(jjtn001);
                         jjtc001 = false;
                       } else {
                         jjtree.popNode();
                       }
                       if (jjte001 instanceof RuntimeException) {
                         throw (RuntimeException)jjte001;
                       }
                       if (jjte001 instanceof ParseException) {
                         throw (ParseException)jjte001;
                       }
                       throw (Error)jjte001;
                     } finally {
                       if (jjtc001) {
                         jjtree.closeNodeScope(jjtn001,  2);
                       }
                     }
/*@egen*/                    ]
}

void param() : {/*@bgen(jjtree) param */
                ASTparam jjtn000 = new ASTparam(JJTPARAM);
                boolean jjtc000 = true;
                jjtree.openNodeScope(jjtn000);
/*@egen*/Token t; String name;} 
{/*@bgen(jjtree) param */
    try {
/*@egen*/
    name = id() <COLON> t = <TYPE>/*@bgen(jjtree) #VAR( 1) */
        {
          ASTVAR jjtn001 = new ASTVAR(JJTVAR);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
        }
        try {
/*@egen*//*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn001,  1);
          jjtc001 = false;
        }
/*@egen*/
        {
            jjtn001.value = t.image;
            ST.insert(name, t.image); 
            //ST.insert(name);
        }/*@bgen(jjtree)*/
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  1);
          }
        }
/*@egen*/        /*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/** CONDITION **/
void condition() : {/*@bgen(jjtree) condition */
  ASTcondition jjtn000 = new ASTcondition(JJTCONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}   
{/*@bgen(jjtree) condition */
    try {
/*@egen*/
    simple_condition() (log_ops() simple_condition())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void simple_condition() : {/*@bgen(jjtree) simple_condition */
  ASTsimple_condition jjtn000 = new ASTsimple_condition(JJTSIMPLE_CONDITION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) simple_condition */
    try {
/*@egen*/
    <LOG_NEG> condition()
    | <LBR> condition() <RBR>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
    //| expr() comp_ops() expr()
}

void comp_ops() : {/*@bgen(jjtree) comp_ops */
  ASTcomp_ops jjtn000 = new ASTcomp_ops(JJTCOMP_OPS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) comp_ops */
    try {
/*@egen*/
    <EQUALS>
    | <NOT_EQUALS>
    | <LESS_THAN>
    | <LESS_EQUALS>
    | <GREATER_THAN>
    | <GREATER_EQUALS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void log_ops() : {/*@bgen(jjtree) log_ops */
  ASTlog_ops jjtn000 = new ASTlog_ops(JJTLOG_OPS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) log_ops */
    try {
/*@egen*/
    <LOG_DIS>
    | <LOG_AND>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/** MAIN STATEMENT **/
void main_statement() : {/*@bgen(jjtree) main_statement */
  ASTmain_statement jjtn000 = new ASTmain_statement(JJTMAIN_STATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) main_statement */
    try {
/*@egen*/
    {ST.newScope();}
    <MAIN> <BEGIN> (decl_list())* (statement_block())* <END>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {ST.endScope();}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void statement_block()       : {}
{
    (statement() [/*@bgen(jjtree) #statement_block( 2) */
                  {
                    ASTstatement_block jjtn001 = new ASTstatement_block(JJTSTATEMENT_BLOCK);
                    boolean jjtc001 = true;
                    jjtree.openNodeScope(jjtn001);
                  }
                  try {
/*@egen*/statement_block()/*@bgen(jjtree)*/
                  } catch (Throwable jjte001) {
                    if (jjtc001) {
                      jjtree.clearNodeScope(jjtn001);
                      jjtc001 = false;
                    } else {
                      jjtree.popNode();
                    }
                    if (jjte001 instanceof RuntimeException) {
                      throw (RuntimeException)jjte001;
                    }
                    if (jjte001 instanceof ParseException) {
                      throw (ParseException)jjte001;
                    }
                    throw (Error)jjte001;
                  } finally {
                    if (jjtc001) {
                      jjtree.closeNodeScope(jjtn001,  2);
                    }
                  }
/*@egen*/                    ])
}

void statement() : {/*@bgen(jjtree) statement */
  ASTstatement jjtn000 = new ASTstatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statement */
    try {
/*@egen*/
    LOOKAHEAD(2) assign()
    | LOOKAHEAD(2) func_call()
    | <BEGIN> (statement_block())* return_statement() <END>
    | <IF> condition() <BEGIN> (statement_block())* <END>
    | <ELSE> <BEGIN> (statement_block()) * <END>
    | <WHILE> condition() <BEGIN> (statement_block())* <END>
    | <SKIP_WORD> <SEMIC>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void assign() : {/*@bgen(jjtree) assign */
                 ASTassign jjtn000 = new ASTassign(JJTASSIGN);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/String name;}
{/*@bgen(jjtree) assign */
    try {
/*@egen*/
    (name = id() <ASSIGN> expr() <SEMIC>)/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void func_call() : {/*@bgen(jjtree) func_call */
                    ASTfunc_call jjtn000 = new ASTfunc_call(JJTFUNC_CALL);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
/*@egen*/String name;}
{/*@bgen(jjtree) func_call */
    try {
/*@egen*/
    name = id() <LBR> (expr())* <RBR> <SEMIC>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void expr() : {/*@bgen(jjtree) expr */
  ASTexpr jjtn000 = new ASTexpr(JJTEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) expr */
    try {
/*@egen*/
    LOOKAHEAD(3) fragment() bin_op() fragment()
    //| LOOKAHEAD(2) (id())* <LBR> expr() <RBR>
    | arg_list()
    | fragment()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void arg_list() : {/*@bgen(jjtree) arg_list */
  ASTarg_list jjtn000 = new ASTarg_list(JJTARG_LIST);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) arg_list */
    try {
/*@egen*/
    nemp_arg_list()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void nemp_arg_list()       : {String name;}
{
    (name = id() [<COMMA>/*@bgen(jjtree) #nemp_arg_list( 2) */
                          {
                            ASTnemp_arg_list jjtn001 = new ASTnemp_arg_list(JJTNEMP_ARG_LIST);
                            boolean jjtc001 = true;
                            jjtree.openNodeScope(jjtn001);
                          }
                          try {
/*@egen*/ nemp_arg_list()/*@bgen(jjtree)*/
                          } catch (Throwable jjte001) {
                            if (jjtc001) {
                              jjtree.clearNodeScope(jjtn001);
                              jjtc001 = false;
                            } else {
                              jjtree.popNode();
                            }
                            if (jjte001 instanceof RuntimeException) {
                              throw (RuntimeException)jjte001;
                            }
                            if (jjte001 instanceof ParseException) {
                              throw (ParseException)jjte001;
                            }
                            throw (Error)jjte001;
                          } finally {
                            if (jjtc001) {
                              jjtree.closeNodeScope(jjtn001,  2);
                            }
                          }
/*@egen*/                  ])
}

void bin_op() : {/*@bgen(jjtree) bin_op */
  ASTbin_op jjtn000 = new ASTbin_op(JJTBIN_OP);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) bin_op */
    try {
/*@egen*/
    <PLUS_SIGN> 
    | <MINUS_SIGN>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

String fragment() : {/*@bgen(jjtree) fragment */
                      ASTfragment jjtn000 = new ASTfragment(JJTFRAGMENT);
                      boolean jjtc000 = true;
                      jjtree.openNodeScope(jjtn000);
/*@egen*/ String name; Token t; }
{/*@bgen(jjtree) fragment */
    try {
/*@egen*/
    name = id()
    | t = <MINUS_SIGN> name = id()/*@bgen(jjtree)*/
                                   {
                                     jjtree.closeNodeScope(jjtn000, true);
                                     jjtc000 = false;
                                   }
/*@egen*/ {jjtn000.value = t.image; return t.image;}
    | t = <NUM>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ {jjtn000.value = t.image; return t.image;}
    | t = <BOOL>/*@bgen(jjtree)*/
                 {
                   jjtree.closeNodeScope(jjtn000, true);
                   jjtc000 = false;
                 }
/*@egen*/ {jjtn000.value = t.image; return t.image;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

/** SIMPLE TOKENS **/
String id()  : {/*@bgen(jjtree) id */
                 ASTid jjtn000 = new ASTid(JJTID);
                 boolean jjtc000 = true;
                 jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) id */
    try {
/*@egen*/
    t = <ID>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
             }
/*@egen*/ {jjtn000.value = t.image; return t.image;}/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void return_statement() : {/*@bgen(jjtree) return_statement */
  ASTreturn_statement jjtn000 = new ASTreturn_statement(JJTRETURN_STATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/} 
{/*@bgen(jjtree) return_statement */
    try {
/*@egen*/ 
    <RETURN> <LBR> (expr())* <RBR> <SEMIC>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}
